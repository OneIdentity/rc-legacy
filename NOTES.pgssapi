
The Pluggable GSSAPI library
============================

Overview
--------

Pluggable-GSS provides PAM-like configuration to applications using the GSSAPI. 
It allows for new GSSAPI mechanisms to be added to applications without re-linking.

The following diagram indicates the relationship between various executables, files
and the Plugabble GSSAPI library "libpgss.so".

   +-------------+      +-------------+    
   | application |      | application |
   +------+------+      +-+--------+--+    
          |               |        |
          v               v        v
         =======GSSAPI======  ==PGSSAPI==
               |                   |
        +------v-------------------v-+
        |          libpgss.so        |<---- /etc/pgss.d/appname
        +----+-----------------------+
             |                      
             v                      
        =======GSSAPI=======
           |            |
 +---------v------+ +---v-----+
 |libvas-gssapi.so| |libgss.so|<--- /etc/gss/mech.conf
 +----------------+ +---------+
                           |
                           v
                      ====mechglue====
                       |     |     |
                     +-v-+ +-v-+ +-v-+
                     |...| |...| |...|
                     +---+ +---+ +---+

Unlike MIT mechglue, PGSS assumes no 'internal' mechanism API/ABI. 
Instead, the mechanism provider shlib is expected to expose, at minimum
the GSSAPI v1 ABI.

Default configuration is supplied in the file /etc/pgss.d/default; specific
configuration files may 'include' other files.

PGSS application interface
--------------------------

To the application, the PGSSAPI is a superset of the GSSAPI. It extends it 
with a control interface, consisting of a single function:

  OM_uint32 pgss_op(OM_uint32 *minor_ret, OM_uint32 op, const gss_OID mech, 
		gss_buffer_t arg);
  #define PGSS_SET_APP_NAME	0	/* Change application name */
  #define PGSS_BIND_CONFIG	1	/* Load/bind/test the config file now */
  #define PGSSAPI_VERSION	0x10000	/* API version: major << 16 | minor */

When oid is GSS_C_NO_OID, the operation is interpreted as an operation on PGSS
itself.  If PGSS does not understand the operation, the function will return
GSS_S_UNAVAILABLE. Error messages may be rendered using gss_display_status().

If oid is provided, then the operation is attempted on the selected provider. 
If the provider exports _pgss_provider_op(), then that function is called directly.

PGSS provider interface
-----------------------

PGSS determines the interface exposed by a servant shared library by examining 
its symbol table, though this can be altered by configuration (described later).

PGSS will also notice the special name _pgss_provider_op(), indicating a function
with the same signature as pgss_op():

  OM_uint32 _pgss_provider_op(OM_uint32 *, OM_uint32, const gss_OID, gss_buffer_t);
  #define PGSS_PROVIDER_INIT	0	/* provider has just been loaded */

This function too must return GSS_S_UNAVAILABLE for any operation not understood.
In the event of errors, the provider's gss_display_status() function will be
invoked. 

When PGSS loads a library for the first time with this function, the function is
called with operation PGSS_PROVIDER_INIT, mechanism GSS_C_NO_OID, and a read-only 
gss_buffer containing the config initialization string (zero length if unspecified).
This provides the library with an opportunity to configure itself. 

Configuration files
-------------------

When pgss_op(PGSS_BIND_CONFIG) or any GSSAPI operation is invoked, PGSS will
determine the application name, and search for a file in /etc/pgss/ of the 
application name, stripped to the last '/' character. 

The application name is determined in the following order:
	- if the environment variable PGSS_APP_NAME is defined and non-empty, use that
	- otherwise, if PGSS_SET_APP_NAME has been called, and the last call
	  supplied a non-empty buffer, use that
	- otherwise, if a platform-specific technique to get the current
	  executable path is known, use that
	- otherwise, use the string ''
Regardless of how the application name is determined, it is stripped of any 
prefix up to and including the last '/' character. If the resulting string is empty,
then it is replaced with the name 'default'. This becomes the stripped application
name (<name>).

If the environment variable PGSS_CONFIG_DIR is defined and non-empty, then it is
used as a search path. Otherwise, the fixed path /etc/pgss is used as the 
configuration directory (<confdir>).

Next, <confdir>/<name> is opened. If this fails, then <confdir>/default is tried.
If this fails, then the equivalent of an empty file or /dev/null is simulated.

The environment variables are read only once, the first time the configurations
are bound. Re-reading the configuration file is not permitted, however, a server
process that forks may avoid configuration binding by performing (P)GSSAPI operations
only in its child processes.

The syntax of a configuration file is a series of lines of the form

    config-line::
	mech-pattern path (param[=value])*

    mech-pattern::  a shell glob used to match the requested mechanism
		    first expressed as a decimal dot-delimited OID, and then 
		    as a symbolic name. It may contain the '|' character and
		    whitespace

    param[=value]:: modifying parameters. Unknown parameters are logged and ignored.

All words may be quoted using single or double quotes to include whitespace.
The backslash character is used to quote the immediately proceeding character only.
Comments begin with a '#' character.

The param[=value] fields are extensible and as follows:

	type=lib		Path is to be dynamically loaded (default)
	type=include 		Include another config file
	type=alias		Aliases one mechanism to another
	init=init-text		Text passed to provider_op init method
	dlsym=global		Forces library to be loaded with global symbols
	abi=auto		What to force the ABI as (default is auto)
	type=unavailable	Replace with built-in 'unavailable' mechanism.

Unknown parameter names (or values) are treated as errors.

An example configuration file:

	# this is a simple config file
	1.2.840.11354.1.2.2 /usr/lib/libgss.so abi=gssv1
	1.2.3.4	- unavailable             # simulate 1.2.3.4
	* default type=include            # include the default

If a configuration file contains an error, then PGSS treats the config file as if it
were empty. If there is an error loading a provider, or setting a parameter, then 
PGSS simulates the matching mechanism(s) with a dummy one that always returns 
GSS_S_UNAVAILABLE.

The behaviour of PGSS with an empty configuration file is to load no mechanisms;
i.e. gss_indicate_mechs() will return an empty OID set; most GSS operations will
then return GSS_S_BAD_MECH. 

The PGSS_BIND_CONFIG operation can be used to test a configuration.
If there is a problem with the file, then the supplied will be filled with 
a descriptive error/warning message. this happens whether or not the function returns
GSS_S_FAILURE or GSS_S_SUCCESS. (This is the basis of the pgss_check tool.)


Related work
------------

The GSSAPI C standard [RFC2744] describes a compile-time C interface, and not a 
binary interface. Unix security libraries that implement RFC2744 require the 
client application to be compiled against the vendor's GSSAPI headers for reliable
behaviour. Regardless, library implementations of GSSAPI are generally ABI compatible.

The standard focuses on the application side of the interface, and ignores questions
of how mechanism implementations may access the application or each other.

MIT Kerberos contains an internal API, named mechglue, which is suited for
managing the several separate GSSAPI mechanisms into their single GSSAPI library.

http://www.stacken.kth.se/lists/heimdal-discuss/2001-11/msg00010.html
http://www-unix.globus.org/mail_archive/security/2001/Archive/msg00364.html
  - Doug Engert talks about porting GSI to mechglue


Solaris libgss
--------------

Solaris's libgss uses the MIT mechglue interface with a configuration file
at /etc/gss/mech to select dynamically loadable mechanism libraries.

HP-UX have adopted sun's libgss. (available in B.11.00)

http://src.opensolaris.org/source/xref/netvirt/usr/src/lib/libgss/README.spi
  - Solaris' libgss which uses /etc/conf/mech

mech(4):
    Configuration files for libgss

    /etc/gss/mech - each line consists of 5 whitespace-separated fields:
	mechanism-name oid shared-library kernel-module '[' library-options ']'

	kerberos_v5             1.2.840.113554.1.2.2    mech_krb5.so kmech_krb5
	spnego                  1.3.6.1.5.5.2           mech_spnego.so.1 [msinterop]
	diffie_hellman_640_0    1.3.6.4.1.42.2.26.2.4   dh640-0.so.1
	diffie_hellman_1024_0   1.3.6.4.1.42.2.26.2.5   dh1024-0.so.1

    /etc/gss/qop - each line consists of 3 fields:
	qop-name qop-id-number mechanism-name

	GSS_KRB5_INTEG_C_QOP_DES_MD5    0               kerberos_v5
	GSS_KRB5_CONF_C_QOP_DES         0               kerberos_v5


libgss(3lib):

     The shared object libgss.so.1 provides the public interfaces
     defined  below.  

     GSS_C_NT_ANONYMOUS            GSS_C_NT_EXPORT_NAME
     GSS_C_NT_HOSTBASED_SERVICE    GSS_C_NT_MACHINE_UID_NAME
     GSS_C_NT_STRING_UID_NAME      GSS_C_NT_USER_NAME
     gss_accept_sec_context        gss_acquire_cred
     gss_add_cred                  gss_add_oid_set_member
     gss_canonicalize_name         gss_compare_name
     gss_context_time              gss_create_empty_oid_set
     gss_delete_sec_context        gss_display_name
     gss_display_status            gss_duplicate_name
     gss_export_name               gss_export_sec_context
     gss_get_mic                   gss_import_name
     gss_import_sec_context        gss_indicate_mechs
     gss_init_sec_context          gss_inquire_context
     gss_inquire_cred              gss_inquire_cred_by_mech
     gss_inquire_mechs_for_name    gss_inquire_names_for_mech
     gss_process_context_token     gss_release_buffer
     gss_release_cred              gss_release_name
     gss_release_oid               gss_release_oid_set
     gss_seal                      gss_sign
     gss_store_cred                gss_test_oid_set_member
     gss_unseal                    gss_unwrap
     gss_verify                    gss_verify_mic
     gss_wrap                      gss_wrap_size_limit

